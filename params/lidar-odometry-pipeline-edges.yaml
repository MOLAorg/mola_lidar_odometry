# This file holds parameters for mola::LidarInertialOdometry,
# for use either programmatically calling initialize(), or from a MOLA system
# launch file. See "launch/*" examples.

params:
  # These sensor labels will be handled as LIDAR observations:
  # Can be overriden with cli flag --lidar-sensor-label
  lidar_sensor_labels: ['${MOLA_LIDAR_NAME|lidar}', '/ouster/points']

  # Optionally, drop lidar data too close in time:
  min_time_between_scans: 0 # 0.2  # [seconds]
  # Maximum time between two scans to consider the validity of the velocity model:
  max_time_to_use_velocity_model: 2.0 # [seconds]

  # These sensor labels will be handled as IMU observations:
  imu_sensor_label: 'imu'

  # How often to update the local map model:
  local_map_updates:
    min_translation_between_keyframes: 0.25  # [m]
    min_rotation_between_keyframes: 15.0  # [deg]

  # Minimum ICP quality to insert it into the map:
  min_icp_goodness: 0.30

  # Adaptive threshold, as in the KISS-ICP paper:
  adaptive_threshold:
    enabled: true
    initial_sigma: 1.0 #6.0
    min_motion: 0.05

  # - Rest of observations: use these *pointcloud* layers of the observation 
  #   metric_map_t and *insert* them into the local map:
  observation_layers_to_merge_local_map:
    - {from_obs: 'decimated_for_map_smaller_curvature', into_map: 'localmap_small_curvature'}
    - {from_obs: 'decimated_for_map_large_curvature', into_map: 'localmap_large_curvature'}

  # If enabled, a map will be stored in RAM and (if using the CLI) stored
  # to a ".simplemap" file for later use for localization, etc.
  simplemap:
    generate: ${MOLA_GENERATE_SIMPLEMAP|false}   # Can be overriden with CLI flag --output-simplemap
    min_translation_between_keyframes: 0.05   # m
    min_rotation_between_keyframes: 3.0  # deg
    save_final_map_to_file: ${MOLA_SIMPLEMAP_OUTPUT|'final_map.simplemap'}

  # Save the final trajectory in TUM format. Disabled by default.
  estimated_trajectory:
    save_to_file: ${MOLA_SAVE_TRAJECTORY|false}
    output_file: ${MOLA_TUM_TRAJECTORY_OUTPUT|'estimated_trajectory.txt'}

  # If run within a mola-cli container, and mola_viz is present, use these options 
  # to show live progress:
  visualization:
    map_update_decimation: 20

  # Profile the main steps of the odometry pipeline:
  pipeline_profiler_enabled: true
  # Profile the internal steps of the ICP implementation:
  icp_profiler_enabled: true

# If undefined, defaults to be the same than 'icp_settings_with_vel'
#icp_settings_without_vel: ...

# ICP settings can be included from an external YAML file if desired, or defined
# in this same YAML for self-completeness:
# Include example:
#icp_settings_with_vel: $include{./icp-pipeline-edges.yaml}

# ICP parameters definitions:
icp_settings_with_vel:
  # mp2p_icp ICP pipeline configuration file, for use in ICP 
  # odometry and SLAM packages.
  #
  # YAML configuration file for use with the CLI tool mp2p-icp-run or
  # programmatically from function mp2p_icp::icp_pipeline_from_yaml()
  #
  class_name: mp2p_icp::ICP

  # See: mp2p_icp::Parameter
  params:
    maxIterations: 300
    minAbsStep_trans: 1e-4
    minAbsStep_rot: 5e-5

    #debugPrintIterationProgress: true  # Print progress
    #generateDebugFiles: true  # Can be override with env var "MP2P_ICP_GENERATE_DEBUG_FILES=1"
    debugFileNameFormat: "icp-logs/icp-run-${SEQ|NO_SEQ}-$UNIQUE_ID-local_$LOCAL_ID$LOCAL_LABEL-to-global_$GLOBAL_ID$GLOBAL_LABEL.icplog"
    decimationDebugFiles: 100

  solvers:
    - class: mp2p_icp::Solver_GaussNewton
      params:
        maxIterations: 2
        robustKernel: 'RobustKernel::GemanMcClure'
        robustKernelParam: '0.10*ADAPTIVE_THRESHOLD_SIGMA'  # [m]  # (adaptive)
        #innerLoopVerbose: true


  # Sequence of one or more pairs (class, params) defining mp2p_icp::Matcher
  # instances to pair geometric entities between pointclouds.
  matchers:
  #  - class: mp2p_icp::Matcher_Point2Plane
  #    params:
  #      enabled: false
  #      distanceThreshold: 'max(0.2, 0.5*ADAPTIVE_THRESHOLD_SIGMA)'   # [m]
  #      searchRadius: 'min(2.0, 4.0*ADAPTIVE_THRESHOLD_SIGMA)'   # [m]
  #      knn: 6
  #      minimumPlanePoints: 6
  #      planeEigenThreshold: 1e-3
  #      allowMatchAlreadyMatchedGlobalPoints: true # faster
  #      pointLayerMatches:
  #        - {global: "localmap", local: "decimated_for_icp_planes", weight: 1.0}

    - class: mp2p_icp::Matcher_Points_DistanceThreshold
      params:
        threshold: '1.0*ADAPTIVE_THRESHOLD_SIGMA'   # [m]
        thresholdAngularDeg: 0  # deg
        pairingsPerPoint: 1
        allowMatchAlreadyMatchedGlobalPoints: true # faster
        pointLayerMatches:
          - {global: "localmap_large_curvature", local: "decimated_for_icp_large_curvature", weight: 1.0}

    - class: mp2p_icp::Matcher_Points_DistanceThreshold
      params:
        threshold: '3.0*ADAPTIVE_THRESHOLD_SIGMA'   # [m]
        thresholdAngularDeg: 0  # deg
        pairingsPerPoint: 2
        allowMatchAlreadyMatchedGlobalPoints: true # faster
        pointLayerMatches:
          - {global: "localmap_small_curvature", local: "decimated_for_icp_smaller_curvature", weight: 1.0}


  quality:
    - class: mp2p_icp::QualityEvaluator_PairedRatio
      params:
        reuse_icp_pairings: true
        threshold: 0.75 # ignored when 'reuse_icp_pairings'==true
        thresholdAngularDeg: 0
        pointLayerMatches:
            - {global: "localmap_small_curvature", local: "decimated_for_icp_smaller_curvature", weight: 1.0}
            - {global: "localmap_large_curvature", local: "decimated_for_icp_large_curvature", weight: 1.0}



# Local map updates:
# - First time: Using the mp2p_icp pipeline generator:
localmap_generator:
  # Generators:
  #
  # One filter object will be created for each entry, instancing the given class,
  # and with the given parameters. Filters are run in definition order on the
  # incoming raw CObservation objects.
  #
  - class_name: mp2p_icp_filters::Generator
    params:
      target_layer: 'localmap_small_curvature'
      metric_map_definition_ini_file: '${CURRENT_YAML_FILE_PATH}/localmap_definition_voxelmap.ini'
      throw_on_unhandled_observation_class: true
      process_class_names_regex: ''  # NONE: don't process observations in the generator.
      #process_sensor_labels_regex: '.*'
  - class_name: mp2p_icp_filters::Generator
    params:
      target_layer: 'localmap_large_curvature'
      metric_map_definition_ini_file: '${CURRENT_YAML_FILE_PATH}/localmap_definition_voxelmap.ini'
      throw_on_unhandled_observation_class: true
      process_class_names_regex: ''  # NONE: don't process observations in the generator.
      #process_sensor_labels_regex: '.*'


# ---------------------------------------------------------------------------------
# LIDAR observations are, first, loaded using a generator
# from "observations_generator".
# then, optionally, filtered before being registered with ICP
# against the local map with filter "observations_filter".
# ---------------------------------------------------------------------------------
observations_generator:
  # Generators:
  #
  # One filter object will be created for each entry, instancing the given class,
  # and with the given parameters. Filters are run in definition order on the
  # incoming raw CObservation objects.
  #
  - class_name: mp2p_icp_filters::GeneratorEdgesFromCurvature
    params:
      target_layer: 'edges'
      max_cosine: 0.2
      min_point_clearance: 0.10
      throw_on_unhandled_observation_class: true
      process_class_names_regex: '.*'
      process_sensor_labels_regex: '.*'

  - class_name: mp2p_icp_filters::Generator
    params:
      target_layer: 'raw'
      throw_on_unhandled_observation_class: true
      process_class_names_regex: '.*'
      process_sensor_labels_regex: '.*'

observations_filter:
  # Filters:
  #
  # One filter object will be created for each entry, instancing the given class,
  # and with the given parameters. Filters are run in definition order on the
  # input metric_map_t object.
  #

  - class_name: mp2p_icp_filters::FilterDeskew
    params:
      input_pointcloud_layer: 'raw'
      output_pointcloud_layer: 'deskewed'
      silently_ignore_no_timestamps: true # To handle more dataset types
      output_layer_class: 'mrpt::maps::CPointsMapXYZI'  # Keep intensity channel
      
      # These (vx,...wz) are variable names that must be defined via the
      # mp2p_icp::Parameterizable API to update them dynamically.
      twist: [VX,VY,VZ,WX,WY,WZ]

  # Remove points too close, to prevent "noise" from the vehicle, 
  # the person next to the robot, etc. Remove too distant points since
  # the tiniest angular error projects to a large translational error.
  - class_name: mp2p_icp_filters::FilterByRange
    params:
      input_pointcloud_layer: 'deskewed'
      output_pointcloud_layer: 'filtered'
      keep_between: true # Remove points out of this range limits
      range_min: 5.0
      range_max: 1.2*ESTIMATED_SENSOR_MAX_RANGE

  - class_name: mp2p_icp_filters::FilterCurvature
    params:
      input_pointcloud_layer: 'filtered'
      output_layer_larger_curvature: 'large_curvature'
      output_layer_smaller_curvature: 'smaller_curvature'
      #output_layer_other: 'large_curvature'
      max_cosine: 0.2
      min_clearance: 0.05
      max_gap: 1.0

  - class_name: mp2p_icp_filters::FilterDecimateVoxels
    params:
      input_pointcloud_layer: 'large_curvature'
      output_pointcloud_layer: 'decimated_for_icp_large_curvature'
      voxel_filter_resolution: 1.00*1e-2*ESTIMATED_SENSOR_MAX_RANGE  # [m]
      use_closest_to_voxel_average: true

  - class_name: mp2p_icp_filters::FilterDecimateVoxels
    params:
      input_pointcloud_layer: 'large_curvature'
      output_pointcloud_layer: 'decimated_for_map_large_curvature'
      voxel_filter_resolution: 1.0*1e-2*ESTIMATED_SENSOR_MAX_RANGE  # [m]
      use_closest_to_voxel_average: true

  - class_name: mp2p_icp_filters::FilterDecimateVoxels
    params:
      input_pointcloud_layer: 'smaller_curvature'
      output_pointcloud_layer: 'decimated_for_icp_smaller_curvature'
      voxel_filter_resolution: 2.0*1e-2*ESTIMATED_SENSOR_MAX_RANGE  # [m]
      use_closest_to_voxel_average: true

  - class_name: mp2p_icp_filters::FilterDecimateVoxels
    params:
      input_pointcloud_layer: 'smaller_curvature'
      output_pointcloud_layer: 'decimated_for_map_smaller_curvature'
      voxel_filter_resolution: 0.5*1e-2*ESTIMATED_SENSOR_MAX_RANGE  # [m]
      use_closest_to_voxel_average: true

  #- class_name: mp2p_icp_filters::FilterDecimateVoxels
  #  params:
  #    input_pointcloud_layer: 'filtered'
  #    output_pointcloud_layer: 'decimated_for_icp_planes'
  #    voxel_filter_resolution: 10.00*1e-2*ESTIMATED_SENSOR_MAX_RANGE  # [m]
  #    use_closest_to_voxel_average: true

  # Remove layers to save memory and log file storage
  - class_name: mp2p_icp_filters::FilterDeleteLayer
    params:
      pointcloud_layer_to_remove: ['raw', 'deskewed', 'filtered', 'large_curvature', 'smaller_curvature']

